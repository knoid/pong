{"version":3,"sources":["webpack:///./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js","webpack:///./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js","webpack:///./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"names":["logging","utils","shimGetUserMedia","window","navigator","mediaDevices","browserDetails","constraintsToChrome_","c","mandatory","optional","cc","Object","keys","forEach","key","r","ideal","undefined","exact","min","max","oldname_","prefix","name","charAt","toUpperCase","slice","oc","push","mix","advanced","concat","shimConstraints_","constraints","func","version","JSON","parse","stringify","audio","remap","obj","a","b","video","face","facingMode","getSupportedFacingModeLies","getSupportedConstraints","matches","enumerateDevices","then","devices","dev","filter","d","kind","find","some","match","label","toLowerCase","includes","length","deviceId","shimError_","e","PermissionDeniedError","PermissionDismissedError","InvalidStateError","DevicesNotFoundError","ConstraintNotSatisfiedError","TrackStartError","MediaDeviceFailedDueToShutdown","MediaDeviceKillSwitchOn","TabCaptureError","ScreenCaptureError","DeviceCaptureError","message","constraint","constraintName","this","getUserMedia","onSuccess","onError","webkitGetUserMedia","bind","origGetUserMedia","cs","stream","getAudioTracks","getVideoTracks","getTracks","track","stop","DOMException","Promise","reject","shimGetDisplayMedia","getSourceId","getDisplayMedia","sourceId","widthSpecified","width","heightSpecified","height","frameRateSpecified","frameRate","chromeMediaSource","chromeMediaSourceId","maxFrameRate","maxWidth","maxHeight","console","error","shimMediaStream","MediaStream","webkitMediaStream","shimOnTrack","RTCPeerConnection","prototype","transceiver","defineProperty","value","receiver","_ontrack","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","te","getReceivers","id","event","Event","streams","dispatchEvent","apply","arguments","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","_dtmf","createDTMFSender","_pc","getSenders","_senders","origAddTrack","addTrack","sender","origRemoveTrack","removeTrack","idx","indexOf","splice","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","fixChromeStats_","response","standardReport","result","report","standardStats","timestamp","type","localcandidate","remotecandidate","names","stat","makeMapStats","stats","Map","map","successCallbackWrapper_","resolve","shimSenderReceiverGetStats","RTCRtpReceiver","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","existingSenders","newSenders","newSender","shimAddTrackRemoveTrack","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","signalingState","call","t","alreadyExists","oldStream","method","nativeMethod","methodObj","args","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","get","streamid","shimPeerConnection","webkitRTCPeerConnection","addIceCandidateNullSupported","addIceCandidate","RTCIceCandidate","nativeAddIceCandidate","candidate","fixNegotiationNeeded","target"],"mappings":"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","file":"vendors~webrtc-adapter.chrome.d574381aea98e59c6e65.js","sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\nconst logging = utils.log;\n\nexport function shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const browserDetails = utils.detectBrowser(window);\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match =>\n              d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n","/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nexport function shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' +\n        'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      return getSourceId(constraints)\n        .then(sourceId => {\n          const widthSpecified = constraints.video && constraints.video.width;\n          const heightSpecified = constraints.video &&\n            constraints.video.height;\n          const frameRateSpecified = constraints.video &&\n            constraints.video.frameRate;\n          constraints.video = {\n            mandatory: {\n              chromeMediaSource: 'desktop',\n              chromeMediaSourceId: sourceId,\n              maxFrameRate: frameRateSpecified || 3\n            }\n          };\n          if (widthSpecified) {\n            constraints.video.mandatory.maxWidth = widthSpecified;\n          }\n          if (heightSpecified) {\n            constraints.video.mandatory.maxHeight = heightSpecified;\n          }\n          return window.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n","\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = utils.detectBrowser(window);\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window) {\n  const browserDetails = utils.detectBrowser(window);\n\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const addIceCandidateNullSupported =\n    window.RTCPeerConnection.prototype.addIceCandidate.length === 0;\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n\n  // support for addIceCandidate(null or undefined)\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!addIceCandidateNullSupported && !arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions. Native support planned for Chrome M77.\n      if (browserDetails.version < 78 &&\n        arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n\nexport function fixNegotiationNeeded(window) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (pc.signalingState !== 'stable') {\n      return;\n    }\n    return e;\n  });\n}\n"],"sourceRoot":""}